[{"objectID":"1caa46774a7f012a421880f6d268d374f14632cd","permalink":"/post/25-06-01-%E4%BB%8Ejava%E5%85%A5%E9%97%A8%E7%BC%96%E7%A8%8B3-%E5%8F%98%E9%87%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E4%BB%8Ejava%E5%85%A5%E9%97%A8%E7%BC%96%E7%A8%8B3-%E5%8F%98%E9%87%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","title":"从java入门编程(3)-变量与数据类型","content":" 解释代码 public class App { public static void main(String[] args) throws Exception { System.out.println(\u0026amp;#34;Hello, World!\u0026amp;#34;); } } 这段是项目初始代码,这些代码没学过的应该不知道什么意思,但是不需要在意.\n循序渐进即可.\n我们重点关注这行代码:System.out.println(\u0026amp;quot;Hello, World!\u0026amp;quot;);\n这行代码的作用是输出 Hello, World!\n也就是说 System.out.println(); 这行代码的作用就是输出括号里的值\n然后要知道注释\npublic class App { public static void main(String[] args) throws Exception { System.out.println(\u0026amp;#34;Hello, World!\u0026amp;#34;); //此处添加了注释 } } // 是单行注释(除了单行注释还有多行注释)\n写注释的作用是和记笔记一样,为了程序员能够更好地理解代码,//后面的内容会被编译器忽略\n在生成的class文件不会有注释的存在\n声明变量 类似数学题,设一个x为3:\n这其实就相当于我们声明了一个变量x,并且让x=3.那么java里是怎么做的呢?\n在java声明变量的格式是这样的:\u0026amp;lt;数据类型\u0026amp;gt; \u0026amp;lt;变量名\u0026amp;gt;=\u0026amp;lt;值\u0026amp;gt;; 注意要加分号,这是一条语句结束的标志,不加运行会报错.\nint x=3; 这就表明我们声明一个整数变量x,并且赋值为3\nint 表示整数数据类型,关于数据类型后面会讲详细概念,现在知道什么意思就可以\n数字有了,一行字怎么办?\n用 String 类型:\nString y = \u0026amp;quot;ni好1314\u0026amp;quot;; 这行语句便是声明字符串变量y,并且赋值为 ni好1314\n需要特别说明,字符串的数字这个说法,大家可以理解成中文里的 一三一四 这个形式,也就说 1314 和 \u0026amp;quot;1314\u0026amp;quot; 完全是两个概念,前者是个整数,后者是一行字.\n将代码改成下面这样.\npublic class App { public static void main(String[] args) throws …","date":"2025-06-01 00:00:00","updated":"2025-06-01 00:00:00"},{"objectID":"3839d921c1231df2490cd105e3960baa8c9089ee","permalink":"/post/25-05-29-%E4%BB%8Ejava%E5%85%A5%E9%97%A8%E7%BC%96%E7%A8%8B2-%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/","title":"从java入门编程(2)-程序执行流程","content":" 运行流程 下面的内容有些词听不懂没关系,只要明白是一些jdk文件夹里的程序在起作用即可. 当我们点击右上角的小三角后\nVSCode检测Java环境 VSCode 会通过配置的 JDK 环境变量来确认 Java 开发环境是否可用。也就是vscode会优先从系统变量里找javahome(大小写无所谓)变量,但是我们并没有配置,先前只是配置path变量里的可执行文件路径而已,所以我们手动在vscode的设置里配置了javahome的路径. 如果环境变量配置有问题，VSCode 会提示你重新配置 JDK 路径。(也就是报错)\nJava 扩展包的作用 Language Support for Java：这个扩展包会为 Java 文件提供语法高亮、代码补全、错误检查等功能。 Java Extension Pack：它是一个扩展包集合，通常包括调试工具、依赖管理工具(如 Maven 或 Gradle)等。 当你点击运行按钮时，这些扩展包会协同工作，确保代码能够正确编译和运行。\n编译 Java 文件 VSCode 会调用 JDK 中的 javac.exe(Java 编译器) 来编译你的 .java 文件。\n编译过程会检查代码的语法错误、类型错误等，并生成 .class 文件(字节码文件)，这是 Java 程序运行的基础。 .class文件在vscode默认是生成在项目根目录的bin文件夹下,其他编辑器位置可能不同.在项目的.vscode文件夹下有个settings.json文件,在这里为这个java项目做一些单独的配置\n{ \u0026amp;#34;java.project.sourcePaths\u0026amp;#34;: [\u0026amp;#34;src\u0026amp;#34;], \u0026amp;#34;java.project.outputPath\u0026amp;#34;: \u0026amp;#34;bin\u0026amp;#34;, \u0026amp;#34;java.project.referencedLibraries\u0026amp;#34;: [ \u0026amp;#34;lib/**/*.jar\u0026amp;#34; ] } 运行 Java 程序 编译完成后，VSCode 会通过 java.exe 启动 Java 虚拟机(JVM)，并加载生成的 .class 文件。 如果你的程序中有 main 方法，JVM 会从该方法开始执行程序。\n输出结果 程序的输出会显示在 VSCode 的终端或输出窗口中。你可以看到程序的运行结果、打印的调试信息 …","date":"2025-05-29 00:00:00","updated":"2025-05-29 00:00:00"},{"objectID":"8ad07925044c5cef2684c898b1d71da89319a565","permalink":"/post/25-04-20-%E4%BB%8Ejava%E5%85%A5%E9%97%A8%E7%BC%96%E7%A8%8B1-%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/","title":"从java入门编程(1)-配置环境","content":" 按难度筛选 全部 简单 困难 任务 A 任务 B 任务 C 配置java环境 jdk有很多版本,对教学来说区别甚微\n以openjdk17作为java环境\n从清华源镜像下载jdk 将下载的zip解压,我喜欢用一个目录专门存放开发环境和工具\n电脑小白可以去看下windows教程\n然后win+s搜索环境变量\n然后将jdk文件夹bin的目录路径拷贝 之后必须一直点确定否则环境变量不会设置成功\n后面win+r输入cmd 如果没有显示可以重启一次\n解释操作 我们大抵做了两个操作\n我们首先下载解压了openjdk17 配置了环境变量 jdk即Java Development Kit(Java软件开发工具包),没有jdk我们就运行不了java代码\n环境变量是什么? 举个例子,在中学做有关圆的题目时,往往题目后面有: (设Π近似为3.14)\n所以你就知道了Π=3.14\n设置环境变量也就是告诉windows系统设置了一个特殊的值,并且这个值可以是数字,一行文字,但一般是一个文件夹路径\n你可以看到系统变量窗口下有很多变量,而我们则是选中Path变量并新增了一个新值,这里必须要注意系统自带的变量大多只有一个值,而某些变量比较特殊可以有多个值,比如我们选中的Path变量,Path变量规定了命令行界面(也就是那个cmd黑窗口,能通过一些指令对系统做些操作)可执行文件(.exe文件之类的)的搜索路径\n我们在命令行输入 java -version 实际是系统通过Path变量里我们设置的路径(如D:\\Dev\\jdk-17.0.15+6\\bin)找到了java.exe(在cmd里可以一般省略.exe后缀)这个程序 并且执行了java.exe,而 -version 则是对启动java.exe的启动参数(不知道什么意思没关系)\n配置编辑器 接下来我们点击链接下载vscode\nvscode是一个代码编辑器,可以通过安装插件扩展功能\n打开安装包在一直下一步到这个界面安装这个插件 然后重启vscode就变成中文了\n之后搜索java下载这个插件\n后面安装下图流程点击并配置vscode的设置 此处配置javahome与先前配置环境变量同理,只不过是为在vscode安装的java扩展包配置jdk路径\n记得按crtl+s保存,上方的标签左边如果有小白点说明没保存\n我们随意新建一个文件夹,把这个文件夹拖进vscode窗 …","date":"2025-04-20 00:00:00","updated":"2025-04-20 00:00:00"},{"objectID":"aec2d8a126cfd9e41dff76f6f2a73ae7eeaff321","permalink":"/post/25-04-19-%E5%AD%A6java%E5%9F%BA%E7%A1%80%E6%97%B6%E9%9A%BE%E5%A6%82%E7%99%BB%E5%A4%A9%E7%9A%84%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/","title":"java基础学生管理系统","content":" 一个十分简单的称不上项目的学习项目\n但是当时阅历不够做起来也是磕磕碰碰断断续续\n一、项目概述 目标：实现一个基于控制台的“学生信息管理系统”，支持以下功能：\n添加学生 删除学生 修改学生信息 查询所有学生 按学号查询学生 技术点：\nJava 基础语法 类和对象 ArrayList 集合 Scanner 输入 简单的控制台交互逻辑 二、项目结构 StudentManager/ ├── Student.java // 学生实体类 ├── StudentManager.java // 学生管理类 └── Main.java // 程序入口类 三、核心类设计（含详细注释） 1. Student.java（学生实体类） /** * 学生实体类，用于封装学生的基本信息 */ public class Student { private String id; // 学号 private String name; // 姓名 private int age; // 年龄 private double score; // 成绩 /** * 构造方法，用于创建学生对象 * @param id 学号 * @param name 姓名 * @param age 年龄 * @param score 成绩 */ public Student(String id, String name, int age, double score) { this.id = id; this.name = name; this.age = age; this.score = score; } // 当时不知道编辑器都有自动生成的功能写这个是真烦 // lombok确实是好东西 public String getId() { return id; } public void setId(String id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public …","date":"2025-04-19 00:00:00","updated":"2025-04-19 00:00:00"},{"objectID":"b27efe78889d2d1215cadd6ccc03ae47b447ba6f","permalink":"/post/24-10-03-vue3-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F/","title":"vue3 常用的几种组件通讯方式","content":" 一、父子组件通信 1. Props 向下传递 这是 Vue 中最基础的父子组件通信方式。父组件通过 props 将数据传递给子组件。\n父组件：\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;ChildComponent :message=\u0026#34;parentMessage\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ChildComponent from \u0026#39;./ChildComponent.vue\u0026#39;; export default { components: { ChildComponent }, data() { return { parentMessage: \u0026#39;Hello from Parent\u0026#39; }; } }; \u0026lt;/script\u0026gt; 子组件：\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{{ message }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { props: { message: String } }; \u0026lt;/script\u0026gt; 这种方式简单直观，适用于父子组件之间单向数据流的场景。\n2. 事件向上传递 子组件可以通过 $emit 触发事件，并将数据传递给父组件。\n子组件：\n\u0026lt;template\u0026gt; \u0026lt;button @click=\u0026#34;sendMessage\u0026#34;\u0026gt;Send Message\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { methods: { sendMessage() { this.$emit(\u0026#39;message-sent\u0026#39;, \u0026#39;Hello from Child\u0026#39;); } } }; \u0026lt;/script\u0026gt; 父组件：\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;ChildComponent @message-sent=\u0026#34;handleMessage\u0026#34; /\u0026gt; \u0026lt;p\u0026gt;{{ childMessage }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ChildComponent from \u0026#39;./ChildComponent.vue\u0026#39;; export default { components: { ChildComponent }, data() { return { childMessage: \u0026#39;\u0026#39; }; }, methods: { handleMessage(message) { this.childMessage = message; } } }; \u0026lt;/script\u0026gt; 这种方式适用于子组件需要向父组件传递数据的场景。\n二、兄弟组件通信 1. 使用事件总线（不推荐） 虽然 Vue 2 中常用事件总线，但在 Vue 3 中，官方推荐使用其他方式，因为事件总线可能会导致组件之间的耦合度过高，且难以维护。\nvue3需要安装mitt库npm install mitt\nimport { createApp } from \u0026#39;vue\u0026#39;; import App from \u0026#39;./App.vue\u0026#39;; import mitt from \u0026#39;mitt\u0026#39;; const app = createApp(App); const emitter = mitt(); app.config.globalProperties.$bus = emitter; app.mount(\u0026#39;#app\u0026#39;); 组件 A（发布事件）:\n\u0026lt;template\u0026gt; \u0026lt;button @click=\u0026#34;sendMessage\u0026#34;\u0026gt;Send Message\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { methods: { sendMessage() { this.$bus.emit(\u0026#39;message-sent\u0026#39;, \u0026#39;Hello from Component A\u0026#39;); } } }; \u0026lt;/script\u0026gt; 组件 B（监听事件）:\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt;{{ message }}\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data() { return { message: \u0026#39;\u0026#39; }; }, mounted() { this.$bus.on(\u0026#39;message-sent\u0026#39;, (msg) =\u0026gt; { this.message = msg; }); }, beforeUnmount() { this.$bus.off(\u0026#39;message-sent\u0026#39;); } }; \u0026lt;/script\u0026gt; 2. 使用全局状态管理（Pinia） Pinia 是 Vue 3 的官方状态管理库，是 Vuex 的现代替代方案。它提供了更简洁的 API，更好的 TypeScript 支持，并且与 Vue 3 的组合式 API 完美集成。\nPinia Store：\n// stores/shared.js import { defineStore } from \u0026#39;pinia\u0026#39;; export const useSharedStore = defineStore(\u0026#39;shared\u0026#39;, { state: () =\u0026gt; ({ sharedMessage: \u0026#39;\u0026#39; }), actions: { setSharedMessage(message) { this.sharedMessage = message; } } }); 兄弟组件 A：\n\u0026lt;template\u0026gt; \u0026lt;button @click=\u0026#34;sendMessage\u0026#34;\u0026gt;Send Message\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { useSharedStore } from \u0026#39;@/stores/shared\u0026#39;; export default { setup() { const sharedStore = useSharedStore(); const sendMessage = () =\u0026gt; { sharedStore.setSharedMessage(\u0026#39;Hello from Component A\u0026#39;); }; return { sendMessage }; } }; \u0026lt;/script\u0026gt; 兄弟组件 B：\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{{ sharedMessage }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { useSharedStore } from \u0026#39;@/stores/shared\u0026#39;; export default { setup() { const sharedStore = useSharedStore(); const sharedMessage = sharedStore.sharedMessage; return { sharedMessage }; } }; \u0026lt;/script\u0026gt; 这种方式适用于兄弟组件之间需要共享复杂状态的场景。\n3. 使用 Provide/Inject provide 和 inject 是 Vue 3 中用于依赖注入的机制，适用于深度嵌套的组件通信。\n祖先组件：\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;ChildComponent /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { provide, reactive } from \u0026#39;vue\u0026#39;; import ChildComponent from \u0026#39;./ChildComponent.vue\u0026#39;; export default { components: { ChildComponent }, setup() { const sharedData = reactive({ message: \u0026#39;Hello from Ancestor\u0026#39; }); provide(\u0026#39;sharedData\u0026#39;, sharedData); } }; \u0026lt;/script\u0026gt; 后代组件：\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{{ sharedData.message }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { inject } from \u0026#39;vue\u0026#39;; export default { setup() { const sharedData = inject(\u0026#39;sharedData\u0026#39;); return { sharedData }; } }; \u0026lt;/script\u0026gt; 这种方式适用于跨层级组件通信的场景。\n三、跨层级组件通信 1. 使用 Provide/Inject provide 和 inject 是跨层级组件通信的首选方式。它允许祖先组件提供数据，后代组件可以注入并使用这些数据，而无需逐层传递 props。\n2. 使用全局状态管理（Pinia） 对于跨层级组件通信，Pinia 同样适用。通过全局状态管理，任何组件都可以访问和修改共享状态。\n","date":"2024-10-03 00:00:00","updated":"2024-10-03 00:00:00"},{"objectID":"5f97d59c6caba864d41cb7ef69a723953d9a8e05","permalink":"/post/24-09-02-typeorm-create-%E6%96%B9%E6%B3%95%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD%E9%97%AE%E9%A2%98/","title":"TypeORM create方法的类型推断问题","content":" 问题描述 今天从AI那里复制了一段代码,逻辑看起来没有问题\nimport { Injectable } from \u0026#39;@nestjs/common\u0026#39;; import { InjectRepository } from \u0026#39;@nestjs/typeorm\u0026#39;; import { Repository } from \u0026#39;typeorm\u0026#39;; import { User } from \u0026#39;./entities/user.entity\u0026#39;; import * as bcrypt from \u0026#39;bcryptjs\u0026#39;; @Injectable() export class UserService { constructor( @InjectRepository(User) private userRepository: Repository\u0026lt;User\u0026gt;, ) {} async createUser(userData: any): Promise\u0026lt;User\u0026gt; { const hashedPassword = bcrypt.hashSync(userData.password, 10); const user = this.userRepository.create({ ...userData, password: hashedPassword }); return this.userRepository.save(user); } } 然而，VSCode 或 TypeScript 编译器可能会报错，提示 create 方法返回的是一个数组，而不是单个 User 对象。我人佛了传个对象，还给我推出数组来了。\n问题发现 1. TypeORM 的 create 方法重载 TypeORM 的 create 方法有多个重载版本：\ncreate\u0026lt;Entity\u0026gt;(entityLike: DeepPartial\u0026lt;Entity\u0026gt;): Entity; create\u0026lt;Entity\u0026gt;(entityLikes: DeepPartial\u0026lt;Entity\u0026gt;[]): Entity[]; 如果你传入一个对象（DeepPartial\u0026lt;Entity\u0026gt;），它会返回一个实体对象（Entity）。 如果你传入一个对象数组（DeepPartial\u0026lt;Entity\u0026gt;[]），它会返回一个实体对象数组（Entity[]）。 2. 为什么 TypeScript 会推断为数组？ TypeScript 的类型推断机制会根据上下文和传入的参数来选择最合适的方法重载版本,但说实话我搞不懂他的逻辑,但是推测如下：\n类型不明确\n如果 userData 的类型不够明确，TypeScript 可能会误判为数组。例如，如果 userData 的类型是 any 或者是一个复杂的类型，TypeScript 可能会无法准确推断其类型。\n上下文类型推断\n如果在调用 create 方法时，上下文中的类型信息不够明确，TypeScript 可能会倾向于选择数组版本。\nTypeORM 的类型定义问题\nTypeORM 的类型定义可能不够精确，导致 TypeScript 的类型推断机制无法正确推断。\n解决方案 方法 1：显式类型断言 在调用 create 方法时，显式地将参数断言为单个对象，而不是数组。这样可以明确告诉 TypeScript 你传入的是一个对象。\nconst user = this.userRepository.create({ ...userData, password: hashedPassword } as User); 方法 2：避免使用对象展开语法 考虑直接构造实体对象，而不是使用对象展开语法。\nconst user = new User(); user.username = userData.username; user.password = hashedPassword; user.roles = userData.roles; 方法 3：检查 userData 的类型 确保 userData 的类型是明确的，而不是 any 或者一个复杂的类型。例如：\ninterface UserData { username: string; password: string; roles: string[]; } async createUser(userData: UserData): Promise\u0026lt;User\u0026gt; { const hashedPassword = bcrypt.hashSync(userData.password, 10); const user = this.userRepository.create({ ...userData, password: hashedPassword }); return this.userRepository.save(user); } 总结 三种方法都可以解决,推荐第三种 不过还是感受到了ts真是一门屎上雕花的艺术\n","date":"2024-09-02 00:00:00","updated":"2024-09-02 00:00:00"},{"objectID":"2a2336941e509aa4eb4af8b1c3af548c0c118d5f","permalink":"/post/24-08-25-%E6%96%B0%E5%BB%BAvue%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/","title":"新建vue项目的最佳实践","content":" Vite 初始化 pnpm create vite 选项 内容 Project name: vite-project(自定义) Select a framework: Vue Select a variant: Official Vue Starter 请选择要包含的功能： TypeScript, Router（单页面应用开发）, Pinia（状态管理）, Vitest（单元测试）, ESLint（错误预防）, Prettier（代码格式化） 选择要包含的试验特性： none 之后执行：\npnpm i 安装额外依赖：\npnpm i -D @iconify/json autoprefixer cssnano postcss-html postcss-load-config postcss-scss rimraf rollup-plugin-visualizer sass-embedded stylelint stylelint-config-recess-order stylelint-config-recommended-vue stylelint-config-standard-scss stylelint-prettier unplugin-icons vite-plugin-compression ESLint 配置 eslint.config.ts 定义：\nimport { globalIgnores } from \u0026#34;eslint/config\u0026#34;; import { defineConfigWithVueTs, vueTsConfigs, } from \u0026#34;@vue/eslint-config-typescript\u0026#34;; import pluginVue from \u0026#34;eslint-plugin-vue\u0026#34;; import skipFormatting from \u0026#34;@vue/eslint-config-prettier/skip-formatting\u0026#34;; export default defineConfigWithVueTs( { name: \u0026#34;app/files-to-lint\u0026#34;, files: [\u0026#34;**/*.{ts,mts,tsx,vue}\u0026#34;], }, globalIgnores([\u0026#34;**/dist/**\u0026#34;, \u0026#34;**/dist-ssr/**\u0026#34;, \u0026#34;**/coverage/**\u0026#34;]), pluginVue.configs[\u0026#34;flat/recommended\u0026#34;], vueTsConfigs.recommended, skipFormatting ); Prettier 配置 .prettierrc.json 定义：\n{ \u0026#34;printWidth\u0026#34;: 100 } PostCSS 配置 postcss.config.js 定义：\n// @ts-check /** @type {import(\u0026#39;postcss-load-config\u0026#39;).Config} */ export default { plugins: { ...(process.env.NODE_ENV === \u0026#34;production\u0026#34; ? { cssnano: {} } : {}), }, }; Stylelint 配置 stylelint.config.js 定义：\n// @ts-check /** @type {import(\u0026#34;stylelint\u0026#34;).Config} */ export default { extends: [ \u0026#34;stylelint-config-standard-scss\u0026#34;, \u0026#34;stylelint-config-recommended-vue\u0026#34;, \u0026#34;stylelint-config-recess-order\u0026#34;, \u0026#34;stylelint-prettier/recommended\u0026#34;, ], overrides: [ { files: [\u0026#34;**/*.{vue,html}\u0026#34;], customSyntax: \u0026#34;postcss-html\u0026#34;, }, { files: [\u0026#34;**/*.scss\u0026#34;], customSyntax: \u0026#34;postcss-scss\u0026#34;, }, ], rules: { \u0026#34;prettier/prettier\u0026#34;: true, \u0026#34;selector-class-pattern\u0026#34;: null, \u0026#34;no-descending-specificity\u0026#34;: null, \u0026#34;selector-pseudo-class-no-unknown\u0026#34;: [ true, { ignorePseudoClasses: [\u0026#34;deep\u0026#34;, \u0026#34;global\u0026#34;], }, ], \u0026#34;selector-pseudo-element-no-unknown\u0026#34;: [ true, { ignorePseudoElements: [\u0026#34;v-deep\u0026#34;, \u0026#34;v-global\u0026#34;, \u0026#34;v-slotted\u0026#34;], }, ], \u0026#34;at-rule-no-unknown\u0026#34;: [ true, { ignoreAtRules: [ \u0026#34;tailwind\u0026#34;, \u0026#34;apply\u0026#34;, \u0026#34;variants\u0026#34;, \u0026#34;responsive\u0026#34;, \u0026#34;screen\u0026#34;, \u0026#34;function\u0026#34;, \u0026#34;if\u0026#34;, \u0026#34;each\u0026#34;, \u0026#34;include\u0026#34;, \u0026#34;mixin\u0026#34;, \u0026#34;use\u0026#34;, ], }, ], \u0026#34;rule-empty-line-before\u0026#34;: [ \u0026#34;always\u0026#34;, { ignore: [\u0026#34;after-comment\u0026#34;, \u0026#34;first-nested\u0026#34;], }, ], \u0026#34;unit-no-unknown\u0026#34;: [true, { ignoreUnits: [\u0026#34;rpx\u0026#34;] }], }, ignoreFiles: [ \u0026#34;**/*.{js,ts,jsx,tsx}\u0026#34;, \u0026#34;report.html\u0026#34;, \u0026#34;dist/**\u0026#34;, \u0026#34;node_modules/**\u0026#34;, ], }; TypeScript 配置 在 tsconfig.app.json 添加：\n\u0026#34;sourceMap\u0026#34;: true, \u0026#34;forceConsistentCasingInFileNames\u0026#34;: true Vite 配置 vite.config.ts 配置插件：\nimport { fileURLToPath, URL } from \u0026#34;node:url\u0026#34;; import { defineConfig } from \u0026#34;vite\u0026#34;; import vue from \u0026#34;@vitejs/plugin-vue\u0026#34;; import vueDevTools from \u0026#34;vite-plugin-vue-devtools\u0026#34;; import Icons from \u0026#34;unplugin-icons/vite\u0026#34;; import visualizer from \u0026#34;rollup-plugin-visualizer\u0026#34;; import viteCompression from \u0026#34;vite-plugin-compression\u0026#34;; export default defineConfig({ plugins: [ vue(), vueDevTools(), Icons({ compiler: \u0026#34;vue3\u0026#34;, }), process.env.npm_lifecycle_event === \u0026#34;report\u0026#34; ? visualizer({ open: true, brotliSize: true, filename: \u0026#34;report.html\u0026#34; }) : (null as any), process.env.NODE_ENV === \u0026#34;production\u0026#34; ? viteCompression({ algorithm: \u0026#34;gzip\u0026#34;, threshold: 10240, compressionOptions: { level: 9, }, }) : (null as any), ], resolve: { alias: { \u0026#34;@\u0026#34;: fileURLToPath(new URL(\u0026#34;./src\u0026#34;, import.meta.url)), }, }, }); ","date":"2024-08-25 00:00:00","updated":"2024-08-25 00:00:00"},{"objectID":"75234283f1f48633415c4607b51e68b17601aee3","permalink":"/post/24-08-19-pure-admin-http%E5%B7%A5%E5%85%B7%E7%B1%BB%E8%A7%A3%E6%9E%90/","title":"Pure-Admin-http工具类解析","content":" types.d.ts类型定义 1. 引入类型 import type { Method, AxiosError, AxiosResponse, AxiosRequestConfig } from \u0026amp;#34;axios\u0026amp;#34;; 从 axios 里引入了一些类型，后面会用到。比如：\nMethod：HTTP 方法（get、post、put\u0026amp;hellip;） AxiosError：请求错误类型 AxiosResponse：响应类型 AxiosRequestConfig：请求配置类型 2. 定义响应数据结构 export type resultType = { accessToken?: string; }; 这只是一个示例类型，表示接口返回的数据结构里可能有一个 accessToken 字段，实际项目里你可以换成你自己的。(删了也行)\n3. 限制 HTTP 方法 export type RequestMethods = Extract\u0026amp;lt; Method, \u0026amp;#34;get\u0026amp;#34; | \u0026amp;#34;post\u0026amp;#34; | \u0026amp;#34;put\u0026amp;#34; | \u0026amp;#34;delete\u0026amp;#34; | \u0026amp;#34;patch\u0026amp;#34; | \u0026amp;#34;option\u0026amp;#34; | \u0026amp;#34;head\u0026amp;#34; \u0026amp;gt;; RequestMethods 是 axios 中 Method 的子集，只保留了常用的几种 HTTP 方法(也就是第二个参数)。\n4. 扩展错误类型 export interface PureHttpError extends AxiosError { isCancelRequest?: boolean; } 给 AxiosError 加了一个字段 isCancelRequest，用来标记是否是主动取消的请求。\n5. 扩展请求配置类型 export interface PureHttpRequestConfig extends AxiosRequestConfig { beforeRequestCallback?: (request: PureHttpRequestConfig) =\u0026amp;gt; void; beforeResponseCallback?: (response: PureHttpResponse) =\u0026amp;gt; void; } 在 axios …","date":"2024-08-19 00:00:00","updated":"2024-08-19 00:00:00"},{"objectID":"5455514ad6e9538895831850084546ddd2055d50","permalink":"/post/24-08-17-js%E5%8E%9F%E5%9E%8B%E9%93%BE/","title":"JS原型链","content":" 1. 基本概念 在 JavaScript 中，每个对象都有一个内部属性 [[Prototype]]，通常通过 __proto__ 属性或者 Object.getPrototypeOf() 方法来访问。这个属性指向另一个对象，称为该对象的“原型”。如果在对象上查找某个属性或方法时，自身不存在，则会沿着原型链向上查找。\n2. 构造函数与原型对象 构造函数：JavaScript 中的构造函数用于创建对象。例如：\nfunction Person(name) { this.name = name; } 这里的 Person 是一个构造函数。\n原型对象：每个函数都有一个 prototype 属性，它指向一个对象，称为“原型对象”。构造函数的 prototype 属性是其创建的实例对象的原型。\n原型对象是用来共享属性和方法\n原型对象的属性和方法会被继承到所有通过原型链与他相连的对象\n实例对象：通过构造函数创建的对象称为实例对象。实例对象的 __proto__ 指向构造函数的 prototype。 也就是 构造函数原型就是实例对象原型\nlet person1 = new Person(\u0026#34;Alice\u0026#34;); console.log(person1.__proto__ === Person.prototype); // true 3. 原型链的形成 当访问一个对象的属性或方法时，JavaScript 会先在对象自身查找。如果找不到，就会沿着对象的 __proto__ 指向的原型对象继续查找。如果原型对象中也找不到，就会继续沿着原型对象的 __proto__ 查找，直到找到或者到达原型链的末端（null）。\n例如：\nPerson.prototype.sayHello = function() { return `Hello, my name is ${this.name}`; }; let person1 = new Person(\u0026#34;Alice\u0026#34;); console.log(person1.sayHello()); // 输出：Hello, my name is Alice 这里 person1 自身没有 sayHello 方法，但它会沿着原型链查找，最终在 Person.prototype 中找到。\n4. 原型链的层级结构 原型链的层级结构是从实例对象开始，逐级向上查找，直到 Object.prototype，最后指向 null。例如：\nconsole.log(person1.__proto__ === Person.prototype); // true console.log(person1.__proto__.__proto__ === Object.prototype); // true console.log(person1.__proto__.__proto__.__proto__ === null); // true 5. 原型链的优缺点 优点：\n代码复用：通过原型链，多个实例可以共享原型对象上的属性和方法。 动态继承：可以在运行时修改原型对象，从而影响所有实例。 缺点：\n性能问题：如果原型链过长，查找属性或方法可能会变得缓慢。 引用类型共享问题：如果原型上是引用类型，所有实例都会共享同一个引用，可能会导致意外的副作用。 6. 使用原型链的注意事项 避免修改内置对象的原型：修改 Object.prototype 或其他内置对象的原型可能会导致不可预测的行为。 合理设计原型链：尽量避免过长的原型链，以提高性能。 谨慎使用 instanceof：instanceof 是通过原型链来判断对象是否为某个构造函数的实例，但可能会因为原型链的修改而产生意外结果。 7. 示例代码 function Person(name) { this.name = name; } Person.prototype.sayHello = function() { return `Hello, my name is ${this.name}`; }; let person1 = new Person(\u0026#34;Alice\u0026#34;); let person2 = new Person(\u0026#34;Bob\u0026#34;); console.log(person1.sayHello()); // Hello, my name is Alice console.log(person2.sayHello()); // Hello, my name is Bob console.log(person1.__proto__ === Person.prototype); // true console.log(person2.__proto__ === Person.prototype); // true console.log(person1.__proto__.__proto__ === Object.prototype); // true ","date":"2024-08-17 00:00:00","updated":"2024-08-17 00:00:00"},{"objectID":"8526fbe70ecec7e6e4af14eb649ebee76be63e12","permalink":"/post/24-08-17-js%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E9%97%AD%E5%8C%85/","title":"JS作用域链、闭包","content":" 1. 作用域链：一层层抽屉找变量 1.1 作用域（Scope） 作用域就是“变量能起作用的范围”。JS 只有三种作用域：\n全局作用域：最外层抽屉，整个房间都能访问。 函数作用域：函数内部专属抽屉，函数外访问不到。 块级作用域（ES6）：let/const 一对大括号 {} 就是一个抽屉，比 var 更精细。 1.2 作用域链（Scope Chain） 当代码要取一个变量时，引擎会从当前抽屉开始一层层往外翻，直到全局抽屉为止，这条翻抽屉的路径就叫“作用域链”。\nvar a = 1; // 全局抽屉 function foo() { var b = 2; // foo 抽屉 function bar() { var c = 3; // bar 抽屉 console.log(a + b + c); // 找不到 → 去 foo → 再找不到 → 去全局 } bar(); } foo(); // 6 查找顺序：bar 抽屉 → foo 抽屉 → 全局抽屉，像链式调用，所以叫“链”。\n2. 闭包：函数打包带走抽屉 2.1 定义 闭包 = 函数 + 函数声明时所在的词法作用域（即它的诞生环境）。\n函数把当时能访问到的变量一起“打包”带走，即使外层函数早已执行完。\n2.2 为什么需要闭包 隐藏数据（私有变量） 维持状态（计数器、缓存） 函数工厂（批量生成相似行为的函数） 2.3 经典例子：计数器工厂 function makeCounter() { let count = 0; // 这个变量本该在 makeCounter 执行完就销毁 return function () { // 但返回的匿名函数把它带走了 return ++count; }; } const counterA = makeCounter(); const counterB = makeCounter(); counterA(); // 1 counterA(); // 2 counterB(); // 1 (两个闭包互不影响) 解释步骤：\nmakeCounter() 执行完，本来 count 应该被垃圾回收。 但返回的函数引用了 count，引擎为了让它能继续用，就把 count 所在的抽屉整体打包给返回函数。 每次调用 counterA()，访问的都是同一份 count，所以能持续累加。 2.4 误区 \u0026amp; 考题 for (var i = 0; i \u0026lt; 3; i++) { setTimeout(() =\u0026gt; console.log(i), 0); } // 输出 3 3 3 而不是 0 1 2 原因分析:\n变量作用域与异步机制： 使用 var 声明的变量 i 具有函数作用域（而非块级作用域），循环结束后 i 的值为 3。‌‌‌‌ setTimeout 是异步函数，其回调函数会被放入任务队列，等待主线程执行完毕（即循环结束后）才执行。此时所有回调函数访问的 i 均为最终的 3。‌‌‌‌ 若需按顺序打印 0, 1, 2，可通过以下方式实现：\n使用 let 声明变量： for (let i = 0; i \u0026lt; 3; i++) { setTimeout(() =\u0026gt; console.log(i), 0); } let 为块级作用域，每次循环会创建一个新的 i，回调函数捕获的是当前迭代的 i 值。‌‌‌‌\n立即执行函数（IIFE）： for (var i = 0; i \u0026lt; 3; i++) { (function (a) { setTimeout(() =\u0026gt; console.log(a), 0); })(i); } 通过闭包保存每次循环的 i 值。‌‌‌‌\n3. 总结 作用域链：找变量时从里到外翻抽屉。 闭包：函数把外层抽屉“打包”带走，即使外层函数早已结束，抽屉里的变量还活着。 ","date":"2024-08-17 00:00:00","updated":"2024-08-17 00:00:00"},{"objectID":"33eee018208c87292d73d11775d773116bff80d6","permalink":"/post/24-06-29-springboot%E5%B8%B8%E7%94%A8%E4%BE%9D%E8%B5%96/","title":"springboot常用依赖","content":" \u0026lt;properties\u0026gt; \u0026lt;revision\u0026gt;1.0.0\u0026lt;/revision\u0026gt; \u0026lt;java.version\u0026gt;17\u0026lt;/java.version\u0026gt; \u0026lt;knife4j.version\u0026gt;4.5.0\u0026lt;/knife4j.version\u0026gt; \u0026lt;fastexcel.version\u0026gt;1.2.0\u0026lt;/fastexcel.version\u0026gt; \u0026lt;mybatis-plus.version\u0026gt;3.5.12\u0026lt;/mybatis-plus.version\u0026gt; \u0026lt;mapstruct-plus.version\u0026gt;1.4.8\u0026lt;/mapstruct-plus.version\u0026gt; \u0026lt;mapstruct-plus.lombok.version\u0026gt;0.2.0\u0026lt;/mapstruct-plus.lombok.version\u0026gt; \u0026lt;hutool-all.version\u0026gt;5.8.38\u0026lt;/hutool-all.version\u0026gt; \u0026lt;satoken.version\u0026gt;1.44.0\u0026lt;/satoken.version\u0026gt; \u0026lt;springdoc.version\u0026gt;2.5.0\u0026lt;/springdoc.version\u0026gt; \u0026lt;spring-admin.version\u0026gt;3.5.0\u0026lt;/spring-admin.version\u0026gt; \u0026lt;sms4j.version\u0026gt;3.3.5\u0026lt;/sms4j.version\u0026gt; \u0026lt;ip2region.version\u0026gt;2.7.0\u0026lt;/ip2region.version\u0026gt; \u0026lt;redisson.version\u0026gt;3.50.0\u0026lt;/redisson.version\u0026gt; \u0026lt;lock4j.version\u0026gt;2.2.7\u0026lt;/lock4j.version\u0026gt; \u0026lt;simple-java-mail.version\u0026gt;8.12.6\u0026lt;/simple-java-mail.version\u0026gt; \u0026lt;easy-captcha.version\u0026gt;1.6.2\u0026lt;/easy-captcha.version\u0026gt; \u0026lt;UserAgentUtils.version\u0026gt;1.21\u0026lt;/UserAgentUtils.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!-- 权限认证 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;cn.dev33\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sa-token-spring-boot3-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${satoken.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;cn.dev33\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sa-token-jwt\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${satoken.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 数据库 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-plus-spring-boot3-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${mybatis-plus.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-plus-jsqlparser\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${mybatis-plus.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.github.linpeilie\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mapstruct-plus-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${mapstruct-plus.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 监控 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;de.codecentric\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-admin-starter-server\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-admin.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;de.codecentric\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-admin-starter-client\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-admin.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 工具 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;cn.hutool\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hutool-all\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${hutool-all.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;cn.idev.excel\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastexcel\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${fastexcel.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 短信 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara.sms4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sms4j-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${sms4j.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 邮箱 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.simplejavamail\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;simple-java-mail\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${simple-java-mail.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 验证码 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.whvcse\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;easy-captcha\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${easy-captcha.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 接口文档 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.xiaoymin\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;knife4j-openapi3-jakarta-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${knife4j.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- IP设备 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;eu.bitwalker\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;UserAgentUtils\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${UserAgentUtils.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.lionsoul\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;ip2region\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${ip2region.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--分布式--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.redisson\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;redisson-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${redisson.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lock4j-redisson-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${lock4j.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;source\u0026gt;${java.version}\u0026lt;/source\u0026gt; \u0026lt;target\u0026gt;${java.version}\u0026lt;/target\u0026gt; \u0026lt;annotationProcessorPaths\u0026gt; \u0026lt;path\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${lombok.version}\u0026lt;/version\u0026gt; \u0026lt;/path\u0026gt; \u0026lt;path\u0026gt; \u0026lt;groupId\u0026gt;io.github.linpeilie\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mapstruct-plus-processor\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${mapstruct-plus.version}\u0026lt;/version\u0026gt; \u0026lt;/path\u0026gt; \u0026lt;path\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok-mapstruct-binding\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${mapstruct-plus.lombok.version}\u0026lt;/version\u0026gt; \u0026lt;/path\u0026gt; \u0026lt;path\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-configuration-processor\u0026lt;/artifactId\u0026gt; \u0026lt;/path\u0026gt; \u0026lt;/annotationProcessorPaths\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;excludes\u0026gt; \u0026lt;exclude\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;/exclude\u0026gt; \u0026lt;/excludes\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;!-- 统一版本号管理 --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.codehaus.mojo\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;flatten-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;updatePomFile\u0026gt;true\u0026lt;/updatePomFile\u0026gt; \u0026lt;flattenMode\u0026gt;resolveCiFriendliesOnly\u0026lt;/flattenMode\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;flatten\u0026lt;/id\u0026gt; \u0026lt;phase\u0026gt;process-resources\u0026lt;/phase\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;flatten\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;flatten.clean\u0026lt;/id\u0026gt; \u0026lt;phase\u0026gt;clean\u0026lt;/phase\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;clean\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; ","date":"2024-06-29 00:00:00","updated":"2024-06-29 00:00:00"},{"objectID":"c09d981a3da609ded64454a2cee17790690c27b5","permalink":"/post/24-06-29-spring%E5%9B%BD%E9%99%85%E5%8C%96/","title":"spring国际化","content":" 0. 实现代码 @NoArgsConstructor(access = AccessLevel.PRIVATE) public final class MessageUtils { // ① 容器启动后拿到 MessageSource Bean private static final MessageSource MESSAGE_SOURCE = SpringUtils.getBean(MessageSource.class); // ② i18n 调用 public static String message(String code, Object... args) { try { return MESSAGE_SOURCE.getMessage(code, args, LocaleContextHolder.getLocale()); } catch (NoSuchMessageException e) { return code; // ③ 兜底 } } } ① 获取 MessageSource 位置 关键源码 ApplicationContext 启动 AbstractApplicationContext#prepareBeanFactory 注册单例\nbeanFactory.registerResolvableDependency(MessageSource.class, context); Boot 自动装配 MessageSourceAutoConfiguration → ResourceBundleMessageSource 业务侧 Hutool SpringUtils.getBean(MessageSource.class) 等价于\napplicationContext.getBean(MessageSource.class) ② LocaleContextHolder.getLocale() 位置 关键源码 DispatcherServlet LocaleContextHolder.setLocale(locale, false); 线程变量 LocaleContextHolder.getLocale() →\ngetLocaleContext().getLocale() ③ MESSAGE_SOURCE.getMessage(\u0026amp;hellip;) …","date":"2024-06-29 00:00:00","updated":"2024-06-29 00:00:00"},{"objectID":"731e2afb565d91c7f96a161883c4f62a3df79ff4","permalink":"/post/24-06-17-ts%E6%B3%9B%E5%9E%8B%E4%B8%8E%E7%AC%A6%E5%8F%B7%E9%80%9F%E6%9F%A5/","title":"TS泛型与符号速查","content":" 1. 占位符 \u0026amp; 默认值 // 占位 function id\u0026lt;T\u0026gt;(x: T): T { return x; } id\u0026lt;number\u0026gt;(42); // T 被替换成 number // 带默认值 type ApiResp\u0026lt;T = any\u0026gt; = { code: number; data: T }; type UserResp = ApiResp\u0026lt;User\u0026gt;; // 指定类型 type AnyResp = ApiResp; // 默认 any 2. 约束 \u0026amp; 多参数 // 约束：参数必须带 length属性 function len\u0026lt;T extends { length: number }\u0026gt;(arr: T) { return arr.length; } len([1, 2, 3]); // OK len({ length: 10 }); // OK len(123); // 报错 // 多参数 type Pair\u0026lt;T, U\u0026gt; = { first: T; second: U }; type NumStr = Pair\u0026lt;number, string\u0026gt;; // { first: number; second: string } 3. 条件类型（if/else） type IsString\u0026lt;T\u0026gt; = T extends string ? true : false; type A = IsString\u0026lt;\u0026#34;hi\u0026#34;\u0026gt;; // true 4. infer —— 把类型「抠」出来 // 剥 Promise type Unwrap\u0026lt;T\u0026gt; = T extends Promise\u0026lt;infer U\u0026gt; ? U : T; type Data = Unwrap\u0026lt;Promise\u0026lt;User[]\u0026gt;\u0026gt;; // User[] // 剥数组 type Item\u0026lt;T\u0026gt; = T extends (infer I)[] ? I : never; type I = Item\u0026lt;number[]\u0026gt;; // number 5. 映射类型（批量改造对象） // 全可选 type MyPartial\u0026lt;T\u0026gt; = { [K in keyof T]?: T[K] }; // 全只读 type MyReadonly\u0026lt;T\u0026gt; = { readonly [K in keyof T]: T[K] }; // 全可 null type Nullable\u0026lt;T\u0026gt; = { [K in keyof T]: T[K] | null }; 6. 递归映射（深层工具） type DeepPartial\u0026lt;T\u0026gt; = { [K in keyof T]?: T[K] extends object ? DeepPartial\u0026lt;T[K]\u0026gt; : T[K]; }; type Config = { db: { host: string; port: number }; cache: boolean }; type Patch = DeepPartial\u0026lt;Config\u0026gt;; // Patch === { db?: { host?: string; port?: number }; cache?: boolean } 7. 索引访问 type User = { id: number; name: string }; type Id = User[\u0026#39;id\u0026#39;]; // number type AllVals = User[keyof User]; // number | string 8. as const + typeof 组合 const arr = [1, 2, 3];// 推导成 number[]，元素可以是任意数量 const arr = [1, 2, 3] as const;// 推导成 readonly [1, 2, 3]，长度固定，值也固定 const ROUTES = { login: \u0026#39;/login\u0026#39;, logout: \u0026#39;/logout\u0026#39; } as const; type RouteKeys = keyof typeof ROUTES; // \u0026#34;login\u0026#34; | \u0026#34;logout\u0026#34; type RouteValues = typeof ROUTES[RouteKeys]; // \u0026#34;/login\u0026#34; | \u0026#34;/logout\u0026#34; // 简化:type Routes = (typeof ROUTES)[keyof typeof ROUTES]; 9. 模板字符串字面量 type Route = `/api/${string}`; // 只能是 \u0026#34;/api/xxx\u0026#34; type Method = `GET ${Route}`; // \u0026#34;GET /api/xxx\u0026#34; type Resource = \u0026#39;users\u0026#39; | \u0026#39;posts\u0026#39; | \u0026#39;comments\u0026#39;; type ApiPath = `/api/${Resource}`; // 效果：\u0026#34;/api/users\u0026#34; | \u0026#34;/api/posts\u0026#34; | \u0026#34;/api/comments\u0026#34; const ROUTES = { login: \u0026#39;/login\u0026#39;, logout: \u0026#39;/logout\u0026#39; } as const; type RouteKeys = keyof typeof ROUTES; // \u0026#34;login\u0026#34; | \u0026#34;logout\u0026#34; type ApiRoutes = `/api${typeof ROUTES[RouteKeys]}`; // \u0026#34;/api/login\u0026#34; | \u0026#34;/api/logout\u0026#34; 10. 可变元组（函数重载终结者） // 取数组尾巴 type Tail\u0026lt;T extends unknown[]\u0026gt; = T extends [any, ...infer Rest] ? Rest : never; type T1 = Tail\u0026lt;[1, 2, 3, 4]\u0026gt;; // [2, 3, 4] type T2 = Tail\u0026lt;[\u0026#39;a\u0026#39;]\u0026gt;; // [] type T3 = Tail\u0026lt;[]\u0026gt;; // never（匹配失败） // 可变参数转数组类型 type Parameters\u0026lt;T\u0026gt; = T extends (...args: infer P) =\u0026gt; any ? P : never; type Fn = (a: number, b: string, ...rest: boolean[]) =\u0026gt; void; type Args = Parameters\u0026lt;Fn\u0026gt;; // =\u0026gt; [number, string, ...boolean[]] 11. 内置工具泛型 Partial\u0026lt;T\u0026gt;; // 全可选 Required\u0026lt;T\u0026gt;; // 全必选 Readonly\u0026lt;T\u0026gt;; // 全只读 Record\u0026lt;K, T\u0026gt;; // { [P in K]: T } Pick\u0026lt;T, K\u0026gt;; // 只留 K 里的键 Omit\u0026lt;T, K\u0026gt;; // 去掉 K 里的键 NonNullable\u0026lt;T\u0026gt;; // 去掉 null/undefined 12. 符号速记表 符号 作用 示例 结果 \u0026amp; 交叉合并对象 {a:string} \u0026amp; {b:number} {a:string; b:number} | 联合（或） string | number 二者之一 ? 可选属性 {name?: string} name 可缺 ! 非空断言 el!.value 告诉 TS 不为 null as 类型断言 x as HTMLElement 强制转换 keyof 取键集合 keyof {a:1,b:2} \u0026quot;a\u0026quot; | \u0026quot;b\u0026quot; typeof 取变量类型 typeof [1,2] number[] ","date":"2024-06-17 00:00:00","updated":"2024-06-17 00:00:00"},{"objectID":"d83af3da01a444f904013d1dfe7b8871d5a9caaa","permalink":"/post/24-06-05-ruoyi-vue-plus%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%B8%8E%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E6%9C%BA%E5%88%B6/","title":"RuoYi-Vue-Plus 的事件与日志记录机制详解","content":" 一、事件机制简介 事件机制是 Spring 框架中的一种设计模式，它允许应用程序在运行时动态地发布和订阅事件。这种机制的核心思想是将事件的发布者（Publisher）和事件的订阅者（Subscriber）解耦，使得两者之间不需要直接的依赖关系。在 RuoYi-Vue-Plus 中，事件机制被用于记录登录信息、操作日志等场景。\n1. 事件对象 事件对象是事件机制中的核心，它封装了事件的所有相关信息。LogininforEvent 是用于记录登录信息的事件对象,代码示例：\n@Data public class LogininforEvent { private String username; // 用户名 private String status; // 登录状态（success/fail/kickout 等） private String message; // 登录消息（如错误信息） private HttpServletRequest request; // 当前请求对象 private Object[] args; } 2. 事件发布 在业务代码中，当需要记录登录信息时，会创建一个 LogininforEvent 对象，并通过 Spring 的事件发布机制将其发布出去。以下是事件发布的代码示例：\nprivate void recordLogininfor(String username, String status, String message) { LogininforEvent event = new LogininforEvent(); event.setUsername(username); event.setStatus(status); event.setMessage(message); event.setRequest(ServletUtils.getRequest()); // 获取当前请求对象 SpringUtils.context().publishEvent(event); // 发布事件 } 这段代码中，SpringUtils.context().publishEvent(event) 是将事件发布到 Spring 的事件广播器中的关键语句。一旦事件被发布，Spring 会自动通知所有订阅了该事件的监听器。\n3. 事件监听 事件 …","date":"2024-06-05 00:00:00","updated":"2024-06-05 00:00:00"},{"objectID":"96ce2621a7cc3b2dd4ca89240bf2005728b72842","permalink":"/post/24-06-05-ruoyi-vue-plus%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4%E5%8A%9F%E8%83%BD/","title":"RuoYi-Vue-Plus数据过滤功能","content":" 一、代码不完整,需结合完整源码 二、核心组件职责说明 组件 类名 核心职责 切面 DataPermissionAspect 前置上下文准备和后置资源清理 拦截器 PlusDataPermissionInterceptor 拦截SQL执行，协调权限处理流程 处理器 PlusDataPermissionHandler 解析注解，生成权限过滤条件 上下文 DataPermissionHelper 管理线程级权限上下文 解析器 JSqlParser 解析和修改SQL语句 枚举 DataScopeType 定义不同数据范围的处理规则 三、详细执行流程分析 阶段0：切面设置权限上下文（前置处理） 执行点：DataPermissionAspect.doBefore()\n@Before(value = \u0026amp;#34;@annotation(dataPermission)\u0026amp;#34;) public void doBefore(JoinPoint joinPoint, DataPermission dataPermission) { // 将Service方法上的注解存入线程上下文 DataPermissionHelper.setPermission(dataPermission); } 关键作用：\n在Service方法执行前捕获@DataPermission注解 通过DataPermissionHelper将注解设置到线程局部变量 建立当前执行的权限规则上下文 阶段0\u0026amp;rsquo;：切面清理上下文（后置处理） 执行点：doAfterReturning()和doAfterThrowing()\n// 正常返回清理 @AfterReturning(pointcut = \u0026amp;#34;@annotation(dataPermission)\u0026amp;#34;) public void doAfterReturning(...) { DataPermissionHelper.removePermission(); } // 异常时清理 @AfterThrowing(value = \u0026amp;#34;@annotation(dataPermission)\u0026amp;#34;, throwing = \u0026amp;#34;e\u0026amp;#34;) public void doAfterThrowing(...) { …","date":"2024-06-05 00:00:00","updated":"2024-06-05 00:00:00"},{"objectID":"f6987c58d726091f835eb68974e1750f4e200cfc","permalink":"/post/24-06-05-ruoyi-vue-plus%E4%B8%AD%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F%E5%8A%9F%E8%83%BD/","title":"RuoYi-Vue-Plus中数据脱敏功能","content":" 1. 注解标注 实体类字段标注：在实体类的字段上添加 @Sensitive 注解，指定脱敏策略和角色权限。例如：\n@Data public class User { @Sensitive(strategy = SensitiveStrategy.PHONE, perms = \u0026amp;#34;system:user:edit\u0026amp;#34;) private String phonenumber; } 这里，phonenumber 字段被标注为使用 PHONE 脱敏策略，并且只有具有 system:user:edit 权限的用户才能看到脱敏后的手机号。\n脱敏注解定义：\n@Retention(RetentionPolicy.RUNTIME) @Target(ElementType.FIELD) @JacksonAnnotationsInside @JsonSerialize(using = SensitiveHandler.class) public @interface Sensitive { SensitiveStrategy strategy(); // 脱敏策略 String[] roleKey() default {}; // 角色标识符，多个角色满足一个即可 String[] perms() default {}; // 权限标识符，多个权限满足一个即可 } 脱敏策略定义：\n@AllArgsConstructor public enum SensitiveStrategy { PHONE(DesensitizedUtil::mobilePhone), ID_CARD(s -\u0026amp;gt; DesensitizedUtil.idCardNum(s, 3, 4)), // 其他策略... private final Function\u0026amp;lt;String, String\u0026amp;gt; desensitizer; public Function\u0026amp;lt;String, String\u0026amp;gt; desensitizer() { return desensitizer; } } 作用： 利用hutool的DesensitizedUtil定义了不同字段类型的脱敏规则。 通过 Function\u0026amp;lt;String, String\u0026amp;gt; 类型的 desensitizer 属性，指定具体的脱敏逻辑。 …","date":"2024-06-05 00:00:00","updated":"2024-06-05 00:00:00"},{"objectID":"8f2d4815e4c3a11dc2de1b7bec37182942a15fb4","permalink":"/post/24-06-04-springboot%E5%AE%9A%E5%88%B6%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E6%96%B9%E6%B3%95/","title":"springboot定制日期格式方法","content":" 1. 全局配置（application.properties/yml） 适用场景：统一整个应用的日期格式\n支持的格式：java.util.Date、java.time.*(如LocalDateTime)（需额外配置）\n# 设置全局日期格式（针对JSON序列化） spring.jackson.date-format=yyyy-MM-dd HH:mm:ss spring.jackson.time-zone=GMT+8 # 设置时区 # 针对Java 8日期类型（如LocalDateTime）需关闭时间戳格式 spring.jackson.serialization.write-dates-as-timestamps=false 2. 使用@JsonFormat注解 适用场景：针对特定字段定制序列化格式\n支持类型：Date、Calendar、java.time.*\npublic class User { @JsonFormat(pattern = \u0026#34;yyyy/MM/dd\u0026#34;, timezone = \u0026#34;Asia/Shanghai\u0026#34;) private Date birthDate; @JsonFormat(pattern = \u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;) private LocalDateTime createTime; } 序列化指将前端传来的json对象转化成java对象\n反序列化则相反\n3. 使用@DateTimeFormat注解 适用场景：处理表单提交或@RequestParam的参数绑定（仅反序列化）\n支持类型：Date、Calendar、java.time.*\npublic class Event { @DateTimeFormat(pattern = \u0026#34;dd-MM-yyyy\u0026#34;) private Date eventDate; } 注意：此注解不影响JSON序列化（返回给前端的格式），需配合@JsonFormat使用。\n4. 自定义全局ObjectMapper 适用场景：完全控制Jackson的日期序列化行为\nimport com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule; import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import java.time.LocalDateTime; import java.time.format.DateTimeFormatter; @Configuration public class JacksonConfig { @Bean public ObjectMapper objectMapper() { ObjectMapper mapper = new ObjectMapper(); // 配置Java 8日期时间类型序列化 JavaTimeModule javaTimeModule = new JavaTimeModule(); javaTimeModule.addSerializer( LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(\u0026#34;yyyy-MM-dd HH:ss\u0026#34;)) ); mapper.registerModule(javaTimeModule); mapper.setDateFormat(DateTimeFormatter.ofPattern(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;)); mapper.setTimeZone(TimeZone.getTimeZone(\u0026#34;GMT+8\u0026#34;)); return mapper; } } 5. 实现Converter接口 适用场景：处理控制器参数绑定（如@RequestParam、@PathVariable）\nimport org.springframework.core.convert.converter.Converter; import org.springframework.stereotype.Component; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; @Component public class StringToDateConverter implements Converter\u0026lt;String, Date\u0026gt; { private final SimpleDateFormat format = new SimpleDateFormat(\u0026#34;yyyy|MM|dd\u0026#34;); @Override public Date convert(String source) { try { return format.parse(source); } catch (ParseException e) { throw new IllegalArgumentException(\u0026#34;日期格式无效: \u0026#34; + source); } } } 6. 自定义Formatter 适用场景：同时处理序列化与反序列化（如Thymeleaf页面渲染）\nimport org.springframework.format.Formatter; import java.text.ParseException; import java.time.LocalDate; import java.time.format.DateTimeFormatter; import java.util.Locale; public class LocalDateFormatter implements Formatter\u0026lt;LocalDate\u0026gt; { private final DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\u0026#34;yyyy/MM/dd\u0026#34;); @Override public LocalDate parse(String text, Locale locale) throws ParseException { return LocalDate.parse(text, formatter); } @Override public String print(LocalDate object, Locale locale) { return object.format(formatter); } } 注册Formatter：\nimport org.springframework.context.annotation.Configuration; import org.springframework.format.FormatterRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; @Configuration public class WebConfig implements WebMvcConfigurer { @Override public void addFormatters(FormatterRegistry registry) { registry.addFormatter(new LocalDateFormatter()); } } 7. ObjectMapper定制器 import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule; import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer; import org.springframework.boot.autoconfigure.AutoConfiguration; import org.springframework.boot.autoconfigure.jackson.Jackson2ObjectMapperBuilderCustomizer; import org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration; import org.springframework.context.annotation.Bean; import java.time.LocalDateTime; import java.time.format.DateTimeFormatter; import java.util.Date; import java.util.TimeZone; @AutoConfiguration(before = JacksonAutoConfiguration.class) public class JacksonConfig { @Bean public Jackson2ObjectMapperBuilderCustomizer customizer() { return builder -\u0026gt; { // 全局配置序列化返回 JSON 处理 JavaTimeModule javaTimeModule = new JavaTimeModule(); DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); javaTimeModule.addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(formatter)); builder.modules(javaTimeModule); builder.timeZone(TimeZone.getDefault()); }; } } 8. 消息转化器 import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.SerializationFeature; import com.fasterxml.jackson.databind.DeserializationFeature; import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule; import org.springframework.context.annotation.Configuration; import org.springframework.http.converter.json.Jackson2ObjectMapperBuilder; import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; @Configuration public class WebConfig implements WebMvcConfigurer { @Override public void configureMessageConverters(List\u0026lt;HttpMessageConverter\u0026lt;?\u0026gt;\u0026gt; converters) { Jackson2ObjectMapperBuilder builder = new Jackson2ObjectMapperBuilder() .indentOutput(true) .dateFormat(new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;)) .modules(new JavaTimeModule()); // 添加Java 8日期时间模块支持 converters.add(new MappingJackson2HttpMessageConverter(builder.build())); } } 个人一般使用ObjectMapper定制器\n","date":"2024-06-04 00:00:00","updated":"2024-06-04 00:00:00"},{"objectID":"ab4b85f88e5880f8f4f3af8abec6141dfa484b7b","permalink":"/post/24-06-01-vscode%E9%85%8D%E7%BD%AE%E5%9B%BE%E5%BD%A2%E5%BA%93%E7%8E%AF%E5%A2%83/","title":"vscode配置图形库环境","content":" 安装环境 vscode下载这一个扩展 w64devkit 下载最新版本复制下载链接到这个网站加速下载\n下载后直接解压即可,复制bin文件夹的路径 win+s搜索环境变量,在path路径配置路径 根据自己的路径来配 一直确定即可配置完毕.\ncmd窗口输入 gcc -v\n要是报错则是路径没配好\n配置easyx easyx下载 将下载的压缩包解压到一个空文件夹\neasyx4mingw_xxxxxxxx.zip ├ include \u0026amp;lt;folder\u0026amp;gt; │\t├ easyx.h // 头文件(提供了当前最新版本的接口) │\t└ graphics.h\t// 头文件(在 easyx.h 的基础上，保留了若干旧接口) ├ lib32 \u0026amp;lt;folder\u0026amp;gt; │\t└ libeasyx.a\t// 针对 TDM-GCC 4.8.1 及以上版本的 32 位库文件 ├ lib64 \u0026amp;lt;folder\u0026amp;gt; │\t└ libeasyx.a\t// 针对 TDM-GCC 4.8.1 及以上版本的 64 位库文件 └ lib-for-devcpp_5.4.0 └ libeasyx.a\t// 适用于 DevCpp 5.4.0 GCC MinGW 4.7.2 和 C-Free 5.0 这是官网指南的文件目录\n在vscode新建一个项目,新建.vscode文件夹,把easyx的include和lib64两个文件夹直接移入项目内 .vscode文件夹新建 tasks.json,参考如下,一定要把 \u0026amp;quot;D:\\\\Dev\\\\w64devkit\\\\bin\\\\g++.exe\u0026amp;quot; 换成自己的路径,也就是先前下载的 w64devkit下的bin文件夹下的g++.exe路径,记得分隔符是两个反斜杠或者一个正斜杠 { \u0026amp;#34;tasks\u0026amp;#34;: [ { \u0026amp;#34;type\u0026amp;#34;: \u0026amp;#34;cppbuild\u0026amp;#34;, \u0026amp;#34;label\u0026amp;#34;: \u0026amp;#34;C/C++: g++.exe 生成活动文件\u0026amp;#34;, \u0026amp;#34;command\u0026amp;#34;: \u0026amp;#34;D:\\\\Dev\\\\w64devkit\\\\bin\\\\g++.exe\u0026amp;#34;, \u0026amp;#34;args\u0026amp;#34;: [ \u0026amp;#34;-fdiagnostics-color=always\u0026amp;#34;, \u0026amp;#34;-g\u0026amp;#34;, …","date":"2024-06-01 08:00:00","updated":"2024-06-01 08:00:00"}]